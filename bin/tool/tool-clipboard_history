#!/bin/bash

### tool-clipboard_history#########################################################################
# A command-line utility to manage clipboard history
# Dependencies: xsel, clipnotify, st, fzf
###################################################################################################

source $(dirname $(readlink -e $0))/helpers

NAME="ó±ƒ” Clipboard"
HISTORY_FILE="$HOME/.clipboard_history"
CLIPBOARD_HISTORY_LIMIT="20"

touch $HISTORY_FILE

function launch-tool() {
    st \
        -g 100x$[$CLIPBOARD_HISTORY_LIMIT + 2] \
        -c float \
        -t "Clipboard History" \
        -e $0 execute
}

function exec-tool() {
    SELECTED=$(
        local x=0
        while read line; do

            # Format each line in fzf with an index prefix so we can find exactly that line.
            ((x++))
            echo "${x} ${line%|*}"

        done < $HISTORY_FILE | fzf \
            --prompt "${NAME}> " \
            --preview "f(){sed -n \"\${1%% *}{p}\" $HISTORY_FILE | awk -F'|' '{print \$NF}' | base64 -d }; f {}"

        # Details on --preview
        # The preview function uses the index at the beginning of the matched line to find that
        # entry in the file, then slices out the actual base64 data and decodes it for the preview.
        # I create a function here to push the matched line into a variable right away so i can use
        # string manipulation to get that index. Explaination below omits escape sequences for
        # readability. The only variable not escaped in the actual command is the $HISTORY_FILE
        # since that's effectivly a constant to the operation.
        #
        # Create a function and pass the line as the first argument
        # f() { ... }; f {}
        #
        # To get the index from the line, we use some bash string manipulation.
        # This expression is visible in the sed statement below.
        # ${1%% *}
        #
        # Next, we need to get that line out of the history file. we use sed for this
        # sed -n "${1%% *}{p}" $HISTORY_FILE
        #
        # Then, pipe that into awk to split on '|' and grab the last entry
        # awk -F'|' '{print $NF}'
        #
        # Lastly, base64 decode the result as that is our preview data.
        # base64 -d
    )
    # User might escape out. If so, exit early.
    [[ "${SELECTED}" == "" ]] && exit

    # find the selected entry (by index), split out the b64, and decode it into the clipboard.
    sed -n "${SELECTED%% *}{p}" $HISTORY_FILE | awk -F'|' '{print $NF}' | base64 -d | xsel -b && \
        notify-send -u low -e "${NAME}" " Clipboard Updated" || \
        notify-send -u critical -e "${NAME}" " Failed to update clipboard!"
}

function monitor() {

    local new_value last_value b64 ol len

    # Get the current length of the history file
    len=$(cat $HISTORY_FILE | wc -l)

    ## Start monitoring for clipboard changes.
    while clipnotify -s clipboard; do

        # Capture the value and make sure it's worth saving.
        new_value=$(xsel -b -o)
        [[ "${last_value}" == "${new_value}" ]] && continue
        [[ "${new_value}" == "" ]] && continue
        last_value="$new_value"

        # Collect the original and one-line version
        b64=$(echo "${new_value}" | base64 -w0)
        ol=$(echo "${new_value}" | tr "\n" " ")

        # Skip it if it's already saved
        grep "${b64}" $HISTORY_FILE 1>/dev/null 2>/dev/null && continue

        # Keep it.
        echo "${ol}|${b64}" >> $HISTORY_FILE

        # Monitor the length and trim the file after $CLIPBOARD_HISTORY_LIMIT lines.
        ((len++))
        if [[ $len -ge $CLIPBOARD_HISTORY_LIMIT ]]; then
            tail -n$CLIPBOARD_HISTORY_LIMIT $HISTORY_FILE > $HISTORY_FILE.old
            mv $HISTORY_FILE.old $HISTORY_FILE
            len=$CLIPBOARD_HISTORY_LIMIT
        fi
    done
}

case "$1" in
execute)
    exec-tool;;
monitor)
    monitor;;
*)
    launch-tool;;
esac
